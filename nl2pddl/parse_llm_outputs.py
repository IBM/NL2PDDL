
"""
This file provides code for parsing raw LLM outputs into 
meaningful Actions and Domains objects usable for metric
computations.
"""

#We disable protected access warnings since we make extensive use
#of protected access to perform an accelerated construction of domains.
# pylint: disable=W0212,W0718

#Standard Libs
import time
import json
import copy
from typing import Any

#External Libs
from pddl.core import Action, Domain
from pddl.parser.domain import DomainParser
from pddl.formatter import domain_to_string
from tqdm import tqdm

#Internal Libs
#from .utils.pddl_properties import *
from .utils.pddl_cache import domainObjMap

def template_domain(domain : Domain):
    """ Creates a templated domain string for a single action in a domain """
    domain_copy = copy.deepcopy(domain)
    domain_copy._actions = {}  # nopep8
    domain_copy_str = domain_to_string(domain_copy)
    return domain_copy_str[:-2] + "{action})"

DOMAIN_TEMPLATES = {domain_name : template_domain(domain_obj) \
                    for domain_name, domain_obj in domainObjMap.items()}
DOMAIN_PARSER = DomainParser()

def matching_closing_paren(s : str) -> int:
    """ Returns the index of the closing ) for the ( at the first pos """
    assert s[0] == '('
    count = 1
    i = 1
    while i < len(s):
        if s[i] == ')':
            count -= 1
        elif s[i] == '(':
            count += 1
        if count == 0:
            return i
        i += 1
    return None

def syntax_check(model_output : str) -> tuple[str, str, str, str]:
    """
    Returns None if the model outputs invalid PDDL, otherwise returns
    the string of the correct PDDL extracted from the model output
    """
    start_index : int = model_output.find("(")
    model_output : str = model_output[start_index:]
    model_output = model_output.strip()
    result : tuple[str, str, str, str]
    if start_index == -1 or model_output[0] != '(':
        result = None, "SyntaxError", "NoPDDL", "Could not find opening ("
    else:
        closing_index = matching_closing_paren(model_output)
        if closing_index is None:
            result = None, "SyntaxError", "ParenMismatch", "Could not find closing )"
        else:
            action_str : str = model_output[:closing_index+1]
            if ":action" not in action_str:
                result = None, "SyntaxError", "NoAction", "Unable to find :action"
            elif ":parameters" not in action_str:
                result = None, "SyntaxError", "NoParams", "Unable to find :parameters"
            elif ":precondition" not in action_str:
                result = None, "SyntaxError", "NoPrecond", "Unable to find :precondition"
            elif ":effect" not in action_str:
                result = None, "SyntaxError", "NoEffect", "Unable to find :effect"
            else:
                result = action_str, "", "", ""
    return result

def str_to_action(model_output : str, domain_name : str) \
-> tuple[Action, str, str, str]:
    """
    Converts a string to a PDDL action object. 
    """
    action_str, result_class, result_subclass, err_msg = \
        syntax_check(model_output)
    if action_str is None:
        return action_str, result_class, result_subclass, err_msg
    action_domain = DOMAIN_TEMPLATES[domain_name].format(action=action_str)
    try:
        tree = DOMAIN_PARSER(action_domain)
        for action in tree.actions:
            return action, "", "", ""
    except Exception as e:
        return None, "SyntaxError", "ParseError", repr(e)

def get_modified_domain(domain_name : str, new_action : Action) \
-> tuple[Domain, str, str, str]:
    """
    Return a new domain with the new action generated by the LLM
    """
    domain_copy : Domain = copy.deepcopy(domainObjMap[domain_name])
    action_name : str = new_action.name
    #linear search for action name since can't const time lookup the set
    for original_action in domain_copy.actions:
        if new_action.name.lower() == original_action.name.lower():
            new_action._name = original_action.name.lower()
            domain_copy._actions = domain_copy.actions.difference({original_action})
            domain_copy._actions = domain_copy.actions.union({new_action})
            return domain_copy, "", "", ""
    #The action name is wrong
    return None, "SemanticError", "DifActionName", "Domain creation error, no match for" +\
          f"{action_name.lower()} in {domain_copy.name}"

def parse_lmm_outputs(results : list[dict[str, Any]]) \
-> list[dict[str, Any]]:
    """
    Parses raw LLM output strings into meaningful Action and Domain objects
    Marks items that can not be parsed with an syntax or semantic error flag,
    which will prevent it from being evaluated upstream.
    """
    parsed_results = []
    for task in tqdm(results):
        task_copy = copy.deepcopy(task)
        for result in task_copy["results"]:
            result["resultClass"] = ""
            result["errorSubclass"] = ""
            result["newDomain"] = ""
            if result["error"]:
                raise f"Model Error, for {task.model}"
            domain_name = task["domain"]
            action, err1, err2, err_msg = str_to_action(result["output"], domain_name)
            if action is None:
                result["error"] = True
                result["resultClass"] = err1
                result["errorSubclass"] = err2
                result["errorMsg"] = err_msg
                continue
            new_domain, err1, err2, err_msg = get_modified_domain(domain_name, action)
            if new_domain is None:
                result["error"] = True
                result["resultClass"] = err1
                result["errorSubclass"] = err2
                result["errorMsg"] = err_msg
                continue
            result["newDomain"] = domain_to_string(new_domain)
        parsed_results.append(task_copy)
    return parsed_results


def parse_llm_outputs_from_file(results_file_path : str) -> list[dict[str, Any]]:
    """
    Given the tasks file generated by call_llm.py, parse the LLM outputs,
    and return the updated tasks file.
    """
    with open(results_file_path, "r", encoding="utf-8") as raw_llm_outputs_file:
        results = json.load(raw_llm_outputs_file)
    return parse_lmm_outputs(results)

def save_parsed_outputs_file(parsed_results, parsed_outputs_path = None):
    """
    Given the parsed llm output task results, save them to a file with an optional
    path.
    """
    if parsed_outputs_path is None:
        timestamp = int(time.time())
        parsed_outputs_path = f"parsedOutputs/parsed-{timestamp}.json"
    with open(parsed_outputs_path, "w", encoding="utf-8") as outfile:
        json.dump(parsed_results, outfile, indent=2)

#By default run on the greedy all outputs.
if __name__ == "__main__":
    parsed = parse_lmm_outputs("outputs/Greedy-All.json")
    save_parsed_outputs_file(parsed)
